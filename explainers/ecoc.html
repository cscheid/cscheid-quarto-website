<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.2.269">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="dcterms.date" content="2020-01-01">

<title>Carlos Scheidegger - Error-Correcting Output Codes</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1.6em;
  vertical-align: middle;
}
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } /* Alert */
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #7d9029; } /* Attribute */
code span.bn { color: #40a070; } /* BaseN */
code span.bu { color: #008000; } /* BuiltIn */
code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4070a0; } /* Char */
code span.cn { color: #880000; } /* Constant */
code span.co { color: #60a0b0; font-style: italic; } /* Comment */
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #ba2121; font-style: italic; } /* Documentation */
code span.dt { color: #902000; } /* DataType */
code span.dv { color: #40a070; } /* DecVal */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #40a070; } /* Float */
code span.fu { color: #06287e; } /* Function */
code span.im { color: #008000; font-weight: bold; } /* Import */
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #007020; font-weight: bold; } /* Keyword */
code span.op { color: #666666; } /* Operator */
code span.ot { color: #007020; } /* Other */
code span.pp { color: #bc7a00; } /* Preprocessor */
code span.sc { color: #4070a0; } /* SpecialChar */
code span.ss { color: #bb6688; } /* SpecialString */
code span.st { color: #4070a0; } /* String */
code span.va { color: #19177c; } /* Variable */
code span.vs { color: #4070a0; } /* VerbatimString */
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
</style>


<script src="../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../site_libs/clipboard/clipboard.min.js"></script>
<script src="../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../site_libs/quarto-search/fuse.min.js"></script>
<script src="../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../">
<script src="../site_libs/quarto-html/quarto.js"></script>
<script src="../site_libs/quarto-html/popper.min.js"></script>
<script src="../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../site_libs/quarto-html/anchor.min.js"></script>
<link href="../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 20,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit"
  }
}</script>

  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

</head>

<body class="nav-fixed fullcontent">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg navbar-dark ">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container">
    <a class="navbar-brand" href="../index.html">
    <span class="navbar-title">Carlos Scheidegger</span>
    </a>
  </div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll ms-auto">
  <li class="nav-item">
    <a class="nav-link" href="../index.html">
 <span class="menu-text">Home</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../blog.html">
 <span class="menu-text">Blog</span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="../blog.xml"><i class="bi bi-rss" role="img">
</i> 
 <span class="menu-text"></span></a>
  </li>  
</ul>
              <div id="quarto-search" class="" title="Search"></div>
          </div> <!-- /navcollapse -->
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<div class="quarto-title-block"><div><h1 class="title">Error-Correcting Output Codes</h1><button type="button" class="btn code-tools-button" id="quarto-code-tools-source"><i class="bi"></i> Code</button></div></div>
  <div class="quarto-categories">
    <div class="quarto-category">explainers</div>
    <div class="quarto-category">data-science</div>
  </div>
  </div>



<div class="quarto-title-meta">

    
    <div>
    <div class="quarto-title-meta-heading">Published</div>
    <div class="quarto-title-meta-contents">
      <p class="date">January 1, 2020</p>
    </div>
  </div>
  
    
  </div>
  

</header>

<p>Often it will be the case that we can model a process we care about as two parties communicating with one another over a <em>noisy channel</em>. Sometimes this is very straightforward: if you’re sending the content of a website to a cellphone, the radio in the cellphone will need to be able to figure out when the message was garbled, and will need to figure out how to fix it. Surprisingly, some techniques in data science also benefit from this change in perspective.</p>
<p>Consider the problem of creating a classifier that can distinguish between more than two classes. We could try to solve this problem from first principles and build that classifier “from nothing”. But if we already know how to build binary classifiers, then we could try to turn the problem of multiple classification into (many instances of) binary classification. The usual way of doing this are called “OVA”, and “AVA”], but there’s a different method that sometimes works better, is elegant, simple to explain, and connects directly to the idea of two parties communicating over a noisy channel.</p>
<section id="prelude-binary-tree-reductions" class="level2">
<h2 class="anchored" data-anchor-id="prelude-binary-tree-reductions">Prelude: Binary-tree reductions</h2>
<p>Let’s first introduce a slightly different, but very simple reduction. Let’s work, for now, with the case of an 8-class problem, so the actual class to be predicted is one of <code>0</code>, <code>1</code>, <code>2</code>, <code>3</code>, <code>4</code>, <code>5</code>, <code>6</code>, or <code>7</code>. What we will do is create a binary tree of decisions, where we will train a binary classifier for each of the nodes. The decisions of each classifier will determine the path that we will walk down the tree, and downstream branches will progressively narrow the set of possible choices. The leaves of this tree represent single classes, and the decision of the overall classifier.</p>
<p>Graphically, it looks like this:</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="ecoc-binary-tree.png" class="img-fluid figure-img"></p>
<p></p><figcaption class="figure-caption">A binary tree to convert single-class predictors into multi-class predictors.</figcaption><p></p>
</figure>
</div>
<p>If you compare this scheme to the OVA and AVA ideas, you can notice a few similarities and a few differences.</p>
<p>First, the number of classifiers you need to train in this scheme is comparable to that of OVA (in a binary tree with <span class="math inline">\(k\)</span> leaves, there are always <span class="math inline">\(k-1\)</span> nodes).</p>
<p>In OVA, all classifiers are unbalanced, in that you’re training “class-<span class="math inline">\(i\)</span> vs.&nbsp;class-not-<span class="math inline">\(i\)</span>” subproblems. Here, your classification problems are all balanced. The leaves of the binary tree classifier are identical to some of the AVA classifiers, but the internal nodes combine multiple classes. This can be both good and bad: it’s bad in that if you have multiple classes that look very different from one another, you’ll be trying to “teach your classifier more than one thing at once”. That’s not great. But if the classes in the same side of the internal nodes are similar enough, then combining them means that the training process for that node will be able to “share knowledge from its lessons”. And that’s a good thing.</p>
<p>Unlike OVA or AVA, the number of decisions you need to make at test time is quite small. Here, the path from the tree root to a leaf has <span class="math inline">\(O(\log k)\)</span> nodes, while OVA needs <span class="math inline">\(O(k)\)</span> classifiers, and AVA, <span class="math inline">\(O(k^2)\)</span>. This means that if your binary classifiers achieve an error rate of <span class="math inline">\(\epsilon\)</span>, then you can trivially see that the multiclass classifier will achieve an error rate of <span class="math inline">\(O(\log k) \epsilon\)</span>.</p>
</section>
<section id="reducing-the-number-of-base-classifiers" class="level2">
<h2 class="anchored" data-anchor-id="reducing-the-number-of-base-classifiers">Reducing the number of base classifiers</h2>
<p>Now let’s make things a little weird. Say that you think your base binary classifier procedure is so good, that it will be able to distinguish between <em>any</em> partition of classes from the original problem that you give it. What’s the minimum number of classifiers you have to train? It is easy to see what that number must be. If you think of the decision of the final multiclass classifier as producing a word in binary, then clearly we need <span class="math inline">\(O(\log_2 k)\)</span> binary digits to write out that word. But a binary digit is the best we can get out of a binary classifier, so we need <span class="math inline">\(O(\log_2 k)\)</span> of them as well.</p>
<p>This also clearly suggests the way to build the classifier: write out the multiple class labels in binary representation, and now the job of the <span class="math inline">\(i\)</span>-th of <span class="math inline">\(\log_2 k\)</span> binary classifiers is to predict the <span class="math inline">\(i\)</span>-th digit of that binary representation. This is the same thing as building, for each of the level of the trees in the above example, a <em>single classifier</em>, where that classifier predicts whether to take the branch on the left or the right.</p>
<p>In other words, for the same 8-class problem we had before, we build classifiers that distinguish between:</p>
<ul>
<li><code>0123</code> vs.&nbsp;<code>4567</code></li>
<li><code>0145</code> vs.&nbsp;<code>2367</code></li>
<li><code>0246</code> vs.&nbsp;<code>1357</code></li>
</ul>
<p>Notice how there’s only one class that’s unique along any possible set of decisions of the binary classifiers. Let’s call this the “binary transmission” method (TODO: find the actual name used in ML).</p>
</section>
<section id="the-magic-of-error-correction" class="level1">
<h1>The magic of error correction</h1>
<p>This is pretty neat, but it turns out that the best is still ahead of us! The main thing we will address now is that it’s not always the case that our classifiers will be correct. And unlike the case with AVA and OVA, base-level mistakes in the binary tree and binary transmission methods are always catastrophic.</p>
<p>The problem of transmitting information in the presence of noise has been deeply studied since the early 20th century. The most magical thing about changing perspectives is that it instantly gives us a lot of new tools to think about a problem. So what if we pretend that each binary classifier is sending its result along a telegraph, in which mistakes can happen along the way? Then, the problem of fixing a transmission mistake looks equivalent to the problem of making a classifier error. So, <em>if we can fix a transmission mistake even if every digit can fail, we might be able to fix a multiclassifier mistake, even if every binary classifier can fail!</em>.</p>
<p>In the following, we will look at a very simple error-correcting code. The <a href="http://hunch.net/~beygel/tournament.pdf">state of the art for error correcting in multiclass classifiers</a> is much more complicated than this, but the principle is the same.</p>
<p>The idea itself behind error correcting codes is simple. Say we want to transmit a word that can be one of <code>000</code>, <code>001</code>, <code>010</code>, <code>011</code>, <code>100</code>, <code>101</code>, <code>110</code>, or <code>111</code>. We will model a transmission error as flipping one of the bits of those words. If we send this representation directly, then any errors that happen in the transmission will become indistinguishable from a successful transmission of a different message. This is a problem, because we won’t even know when something bad happens. It needs to be possible for our communication process to know, by looking at the transmitted word, that something wrong happened. So there needs to be enough <em>room</em> in the space of possible messages for the case where “bad stuff happened”. This means that we will have to <em>encode</em> the word we want to send into a bigger space of possible transmissions, a space with more room.</p>
<p>In addition, in this new space of possible transmission, every codeword should be far away from one another (where we <a href="https://en.wikipedia.org/wiki/Hamming_distance">measure distance by flipping bits</a>, the same process that we assume was introducing mistakes), because we want to give every codeword a “safety cushion” for errors, so that if we get a bad transmission, there’s only one codeword nearby, so we will know how to correct that mistake.</p>
<p>There are simple error detection methods, like sending the same message three times. If any of the words disagree with one another, then we know a mistake happened somewhere (and we correct it by majority voting).</p>
<p>This, however, is not a very efficient code, and most importantly, it will not work in the case of multiclass classification! When sending messages on radio, each error happens (<a href="https://en.wikipedia.org/wiki/Burst_error">well, kinda</a>) independently of one another. But in our case, a mistake happens when a classifier does badly for a given example. So if we just try to “send the same digit three times”, it’ll be the case that if we make a mistake once, then we will make it three times! We need to come up with a better method. (Specifically, I will describe below the <a href="https://en.wikipedia.org/wiki/Hamming(7,4)">Hamming(7,4) code</a>.)</p>
<section id="lets-not-repeat-digits" class="level2">
<h2 class="anchored" data-anchor-id="lets-not-repeat-digits">Let’s not repeat digits</h2>
<p>The code I’m going to describe to you works on 4-bit words, so for now let’s pretend that our original problem had 16 classes instead of 8. The encoding process is itself very easy to describe. We send the 4-bit word into a 7-bit space:</p>
<ul>
<li><span class="math inline">\(A = d\_1\ \textrm{xor}\ d\_2\ \textrm{xor}\ d\_4\)</span></li>
<li><span class="math inline">\(B = d\_1\ \textrm{xor}\ d\_3\ \textrm{xor}\ d\_4\)</span></li>
<li><span class="math inline">\(C = d\_2\ \textrm{xor}\ d\_3\ \textrm{xor}\ d\_4\)</span></li>
<li><span class="math inline">\(D = d\_1\)</span></li>
<li><span class="math inline">\(E = d\_2\)</span></li>
<li><span class="math inline">\(F = d\_3\)</span></li>
<li><span class="math inline">\(G = d\_4\)</span></li>
</ul>
<p>Here, <span class="math inline">\(d\_1\)</span> through <span class="math inline">\(d\_4\)</span> are the digits of the word we want to send. As we argued above, it must be the case that this code is redundant. Indeed, any valid word respects the following equations:</p>
<ul>
<li><span class="math inline">\(A\ \textrm{xor}\ D\ \textrm{xor}\ E\ \textrm{xor}\ G = 0\)</span></li>
<li><span class="math inline">\(B\ \textrm{xor}\ D\ \textrm{xor}\ F\ \textrm{xor}\ G = 0\)</span></li>
<li><span class="math inline">\(C\ \textrm{xor}\ E\ \textrm{xor}\ F\ \textrm{xor}\ G = 0\)</span></li>
</ul>
<p>These equations are easy to prove: remember that <span class="math inline">\(\textrm{xor}\)</span> is commutatitive and associative, and that <span class="math inline">\(a\ \textrm{xor}\ a = 0\)</span>. Moreover, the equations are also the key to making error detection work. Here’s a minor modification we will make. Let’s assume that an error can happen on any digit we send, so we replace <span class="math inline">\(A\)</span> with <span class="math inline">\(\tilde{A}\)</span>, etc:</p>
<ul>
<li><span class="math inline">\(\tilde{A} = \epsilon_A\ \textrm{xor}\ d\_1\ \textrm{xor}\ d\_2\ \textrm{xor}\ d\_4\)</span></li>
<li><span class="math inline">\(\tilde{B} = \epsilon_B\ \textrm{xor}\ d\_1\ \textrm{xor}\ d\_3\ \textrm{xor}\ d\_4\)</span></li>
<li><span class="math inline">\(\tilde{C} = \epsilon_C\ \textrm{xor}\ d\_2\ \textrm{xor}\ d\_3\ \textrm{xor}\ d\_4\)</span></li>
<li><span class="math inline">\(\tilde{D} = \epsilon_D\ \textrm{xor}\ d\_1\)</span></li>
<li><span class="math inline">\(\tilde{E} = \epsilon_E\ \textrm{xor}\ d\_2\)</span></li>
<li><span class="math inline">\(\tilde{F} = \epsilon_F\ \textrm{xor}\ d\_3\)</span></li>
<li><span class="math inline">\(\tilde{G} = \epsilon_G\ \textrm{xor}\ d\_4\)</span></li>
</ul>
<p>Here, we use <span class="math inline">\(\epsilon\_A\)</span>, <span class="math inline">\(\epsilon\_B\)</span>, etc. to model errors in our transmission. The code we are describing here can only correct mistakes if only one of them happens at a time. That means that for every transmission, either <span class="math inline">\(\epsilon\_A = \epsilon\_B = \cdots = 0\)</span>, or a single one of the <span class="math inline">\(\epsilon\)</span> variables is one and all the others are still zero.</p>
<p>This is where the magic happens. Let’s say <span class="math inline">\(\epsilon_A = 1\)</span>. Although it seems like it will be hard to figure out that something went wrong (since the 7-bit word we transmitted “looks fine”), let’s look at those three equations that we derived which describe the redundancy in the code. Now, consider their equivalents with <span class="math inline">\(\tilde{A}\)</span>, etc. I’m also giving each term a name now, <span class="math inline">\(c\_0\)</span> through <span class="math inline">\(c\_2\)</span>:</p>
<ul>
<li><span class="math inline">\(c\_0 = \tilde{A}\ \textrm{xor}\ \tilde{D}\ \textrm{xor}\ \tilde{E}\ \textrm{xor}\ \tilde{G} = \epsilon\_{A}\ \textrm{xor}\ \epsilon\_{D}\ \textrm{xor}\ \epsilon\_{E}\ \textrm{xor}\ \epsilon\_{G}\)</span></li>
<li><span class="math inline">\(c\_1 = \tilde{B}\ \textrm{xor}\ \tilde{D}\ \textrm{xor}\ \tilde{F}\ \textrm{xor}\ \tilde{G} = \epsilon\_{B}\ \textrm{xor}\ \epsilon\_{D}\ \textrm{xor}\ \epsilon\_{F}\ \textrm{xor}\ \epsilon\_{G}\)</span></li>
<li><span class="math inline">\(c\_2 = \tilde{C}\ \textrm{xor}\ \tilde{E}\ \textrm{xor}\ \tilde{F}\ \textrm{xor}\ \tilde{G} = \epsilon\_{C}\ \textrm{xor}\ \epsilon\_{E}\ \textrm{xor}\ \epsilon\_{F}\ \textrm{xor}\ \epsilon\_{G}\)</span></li>
</ul>
<p>Notice two very important things on the right hand sides: every error variable appears at least once, and no error variable was cancelled out from appearing more than once in the left-hand sides.</p>
<p>There’s also a less immediate property of these <span class="math inline">\(c\)</span> variables: <em>every possible mistake case creates a different configuration of <span class="math inline">\(c\_0\)</span>, <span class="math inline">\(c\_1\)</span>, and <span class="math inline">\(c\_2\)</span></em>! This is truly remarkable, and you should check it for yourself, by setting the values of <span class="math inline">\(\epsilon\_A\)</span> through <span class="math inline">\(\epsilon\_G\)</span> to 1. For example, you should be able to convince yourself that if <span class="math inline">\(c\_0 = 0\)</span>, <span class="math inline">\(c\_1 = 1\)</span>, and <span class="math inline">\(c\_2 = 1\)</span>, then it must be the case that <span class="math inline">\(\epsilon\_{F} = 1\)</span>, which means that the mistake happened on <span class="math inline">\(\tilde{F}\)</span>, which in turn means that all we have to do is flip <span class="math inline">\(\tilde{F}\)</span> to obtain <span class="math inline">\(F\)</span>, and all other digits must be correct! If all <span class="math inline">\(c\)</span>s are zero, then no error happened. (Again, we are assuming that errors happen only one at a time. Fate is not always this kind.)</p>
</section>
<section id="now-to-turn-this-into-a-multiclass-reduction" class="level2">
<h2 class="anchored" data-anchor-id="now-to-turn-this-into-a-multiclass-reduction">Now to turn this into a multiclass reduction</h2>
<p>The final remarkable property of this error-correcting code is that each digit in the new transmission is formed by a particular combination of the digits in the original problem. Let’s think of the binary classification problems in the “binary transmission” reduction. (Here, I’ll slip into hexadecimal notation and call the 16 classes <code>0123456789abcdef</code>):</p>
<ul>
<li><span class="math inline">\(d_1\)</span>: <tt>01234567&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</tt> vs.&nbsp;the negative: <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;89abcdef</tt></li>
<li><span class="math inline">\(d_2\)</span>: <tt>0123&nbsp;&nbsp;&nbsp;&nbsp;89ab&nbsp;&nbsp;&nbsp;</tt> vs.&nbsp;the negative: <tt>&nbsp;&nbsp;&nbsp;&nbsp;4567&nbsp;&nbsp;&nbsp;&nbsp;cdef</tt></li>
<li><span class="math inline">\(d_3\)</span>: <tt>01&nbsp;&nbsp;45&nbsp;&nbsp;89&nbsp;&nbsp;cd&nbsp;</tt> vs.&nbsp;the negative: <tt>&nbsp;&nbsp;23&nbsp;&nbsp;67&nbsp;&nbsp;ab&nbsp;&nbsp;ef</tt></li>
<li><span class="math inline">\(d_4\)</span>: <tt>0&nbsp;2&nbsp;4&nbsp;6&nbsp;8&nbsp;a&nbsp;c&nbsp;e</tt> vs.&nbsp;the negative: <tt>&nbsp;1&nbsp;3&nbsp;5&nbsp;7&nbsp;9&nbsp;b&nbsp;d&nbsp;f</tt></li>
</ul>
<p>(The whitespace is there simply to make the logic more apparent.) These are our “base-digits” classifiers. The “checksum-digit” classifiers, that is, the redundant classifiers we will build to let us fix mistakes, will use the <span class="math inline">\(\textrm{xor}\)</span> operation as well. Concretely speaking, the classifier for <span class="math inline">\(d\_1\ \textrm{xor}\ d\_2\ \textrm{xor}\ d\_4\)</span> (that is, our transmitted digit <span class="math inline">\(\tilde{A}\)</span> above) should return a positive label when <span class="math inline">\(d\_1\ \textrm{xor}\ d\_2\ \textrm{xor}\ d\_4 = 1\)</span>, or equivalently, it should separate the classes <code>02579bce</code> from <code>13468adf</code>.</p>
<p>Take a moment to convince yourself of why that makes sense: that split separates the classes that appear in <span class="math inline">\(d\_1\)</span>, <span class="math inline">\(d\_2\)</span>, or <span class="math inline">\(d\_4\)</span> an odd number of times from those that appear there an even number of times. In other words, this classifier will “attempt to send 1” if <span class="math inline">\(d\_1\ \textrm{xor}\ d\_2\ \textrm{xor}\ d\_4 = 1\)</span>, and “attempt to send 0” if <span class="math inline">\(d\_1\ \textrm{xor}\ d\_2\ \textrm{xor}\ d\_4 = 0\)</span>, <em>exactly like our communication example!</em></p>
<p>Now, every time any one of our classifiers makes an isolated mistake, we will be able to spot it and fix it, at the expense of training only three more classifiers. And all of these classifiers are trained on different label distributions, and so we don’t run into the issue of repeated classification mistakes (like we would if we used the “repeat transmission” code).</p>
<p>Isn’t that amazing?</p>
</section>
</section>
<section id="further-reading" class="level1">
<h1>Further reading</h1>
<p>There are a number of details that have to be handled when actually deploying this strategy. The main one is that the choice on how to order the classes to create those splits is quite important, both because we need the individual classifiers to be good, and because we need digit errors to be relatively uncorrelated to one another.</p>
<p>In practice, what the literature suggests is to <em>invent a new custom code for every multiclass classification problem</em>. This is easier than it looks, and if you’re interested, then Dietterich and Bakiri’s <a href="https://arxiv.org/pdf/cs/9501101.pdf">seminal paper</a> is what you should read next. This technique is now known as ECOC (“error-correcting output codes”).</p>
<p>The question of whether ECOC’s are the best we can do remained open for a while, and although it’s still not completely settled, a (much more complicated) solution that combines error correction with the binary tournament idea from above gets pretty close to optimal. These are <a href="https://arxiv.org/abs/0902.3176">error-correcting tournaments</a>, proposed by Beygelzimer et al.&nbsp;I confess I don’t actually understand ECTs all that well, but the good news is that at least they’re implemented in <a href="https://github.com/VowpalWabbit/vowpal_wabbit">Vowpal Wabbit</a>. If each of the base classifiers achieves an average error rate of <span class="math inline">\(\epsilon\)</span>, error-correcting tournaments achieve a multiclass error bound of <span class="math inline">\(2 \epsilon\)</span>. This is independent of the number of classes in the multiclass problem, which is quite incredible.</p>
<section id="notes" class="level2">
<h2 class="anchored" data-anchor-id="notes">Notes</h2>
<ul>
<li>The reason we can’t use the “repeat the same message more than once” trick is that we assumed we were always training the same classifier. If you have two binary classifiers for the same problem that both predict reasonably well, and whose predictions are relatively uncorrelated, then you can absolutely use this “repeat message” method. This turns out to work <a href="https://en.wikipedia.org/wiki/Bootstrap_aggregating">incredibly well in practice</a>!</li>
</ul>


<!-- -->

</section>
</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    target: function(trigger) {
      return trigger.previousElementSibling;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
  const viewSource = window.document.getElementById('quarto-view-source') ||
                     window.document.getElementById('quarto-code-tools-source');
  if (viewSource) {
    const sourceUrl = viewSource.getAttribute("data-quarto-source-url");
    viewSource.addEventListener("click", function(e) {
      if (sourceUrl) {
        // rstudio viewer pane
        if (/\bcapabilities=\b/.test(window.location)) {
          window.open(sourceUrl);
        } else {
          window.location.href = sourceUrl;
        }
      } else {
        const modal = new bootstrap.Modal(document.getElementById('quarto-embedded-source-code-modal'));
        modal.show();
      }
      return false;
    });
  }
  function toggleCodeHandler(show) {
    return function(e) {
      const detailsSrc = window.document.querySelectorAll(".cell > details > .sourceCode");
      for (let i=0; i<detailsSrc.length; i++) {
        const details = detailsSrc[i].parentElement;
        if (show) {
          details.open = true;
        } else {
          details.removeAttribute("open");
        }
      }
      const cellCodeDivs = window.document.querySelectorAll(".cell > .sourceCode");
      const fromCls = show ? "hidden" : "unhidden";
      const toCls = show ? "unhidden" : "hidden";
      for (let i=0; i<cellCodeDivs.length; i++) {
        const codeDiv = cellCodeDivs[i];
        if (codeDiv.classList.contains(fromCls)) {
          codeDiv.classList.remove(fromCls);
          codeDiv.classList.add(toCls);
        } 
      }
      return false;
    }
  }
  const hideAllCode = window.document.getElementById("quarto-hide-all-code");
  if (hideAllCode) {
    hideAllCode.addEventListener("click", toggleCodeHandler(false));
  }
  const showAllCode = window.document.getElementById("quarto-show-all-code");
  if (showAllCode) {
    showAllCode.addEventListener("click", toggleCodeHandler(true));
  }
  function tippyHover(el, contentFn) {
    const config = {
      allowHTML: true,
      content: contentFn,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start'
    };
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      return note.innerHTML;
    });
  }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script><div class="modal fade" id="quarto-embedded-source-code-modal" tabindex="-1" aria-labelledby="quarto-embedded-source-code-modal-label" aria-hidden="true"><div class="modal-dialog modal-dialog-scrollable"><div class="modal-content"><div class="modal-header"><h5 class="modal-title" id="quarto-embedded-source-code-modal-label">Source Code</h5><button class="btn-close" data-bs-dismiss="modal"></button></div><div class="modal-body"><div class="">
<div class="sourceCode" id="cb1" data-shortcodes="false"><pre class="sourceCode markdown code-with-copy"><code class="sourceCode markdown"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="co">---</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="an">title:</span><span class="co"> Error-Correcting Output Codes</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a><span class="an">layout:</span><span class="co"> bootstrap_wide</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a><span class="an">categories:</span><span class="co"> [explainers, data-science]</span></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a><span class="an">date:</span><span class="co"> 2020-01-01</span></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a><span class="co">---</span></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a>Often it will be the case that we can model a process we care about as</span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a>two parties communicating with one another over a *noisy channel*. Sometimes</span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a>this is very straightforward: if you're sending the content of a website to</span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a>a cellphone, the radio in the cellphone will need to be able to figure out</span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a>when the message was garbled, and will need to figure out how to fix it.</span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a>Surprisingly, some techniques in data science also benefit from this</span>
<span id="cb1-14"><a href="#cb1-14" aria-hidden="true" tabindex="-1"></a>change in perspective.</span>
<span id="cb1-15"><a href="#cb1-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-16"><a href="#cb1-16" aria-hidden="true" tabindex="-1"></a>Consider the problem of creating a classifier that can distinguish</span>
<span id="cb1-17"><a href="#cb1-17" aria-hidden="true" tabindex="-1"></a>between more than two classes. We could try to solve this problem from</span>
<span id="cb1-18"><a href="#cb1-18" aria-hidden="true" tabindex="-1"></a>first principles and build that classifier "from nothing". But if we already know</span>
<span id="cb1-19"><a href="#cb1-19" aria-hidden="true" tabindex="-1"></a>how to build binary classifiers, then we could try to turn the problem of multiple classification</span>
<span id="cb1-20"><a href="#cb1-20" aria-hidden="true" tabindex="-1"></a>into (many instances of) binary classification. The usual way of</span>
<span id="cb1-21"><a href="#cb1-21" aria-hidden="true" tabindex="-1"></a>doing this are called "OVA", and "AVA"], but there's a</span>
<span id="cb1-22"><a href="#cb1-22" aria-hidden="true" tabindex="-1"></a>different method that sometimes works better, is elegant, simple to</span>
<span id="cb1-23"><a href="#cb1-23" aria-hidden="true" tabindex="-1"></a>explain, and connects directly to the idea of two parties communicating over</span>
<span id="cb1-24"><a href="#cb1-24" aria-hidden="true" tabindex="-1"></a>a noisy channel.</span>
<span id="cb1-25"><a href="#cb1-25" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-26"><a href="#cb1-26" aria-hidden="true" tabindex="-1"></a><span class="fu">## Prelude: Binary-tree reductions</span></span>
<span id="cb1-27"><a href="#cb1-27" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-28"><a href="#cb1-28" aria-hidden="true" tabindex="-1"></a>Let's first introduce a slightly different, but very simple</span>
<span id="cb1-29"><a href="#cb1-29" aria-hidden="true" tabindex="-1"></a>reduction. Let's work, for now, with the case of an 8-class problem,</span>
<span id="cb1-30"><a href="#cb1-30" aria-hidden="true" tabindex="-1"></a>so the actual class to be predicted is one of <span class="in">`0`</span>, <span class="in">`1`</span>, <span class="in">`2`</span>, <span class="in">`3`</span>, <span class="in">`4`</span>,</span>
<span id="cb1-31"><a href="#cb1-31" aria-hidden="true" tabindex="-1"></a><span class="in">`5`</span>, <span class="in">`6`</span>, or <span class="in">`7`</span>. What we will do is create a binary tree of</span>
<span id="cb1-32"><a href="#cb1-32" aria-hidden="true" tabindex="-1"></a>decisions, where we will train a binary classifier for each of the</span>
<span id="cb1-33"><a href="#cb1-33" aria-hidden="true" tabindex="-1"></a>nodes. The decisions of each classifier will determine the path that</span>
<span id="cb1-34"><a href="#cb1-34" aria-hidden="true" tabindex="-1"></a>we will walk down the tree, and downstream branches will progressively</span>
<span id="cb1-35"><a href="#cb1-35" aria-hidden="true" tabindex="-1"></a>narrow the set of possible choices. The leaves of this tree represent</span>
<span id="cb1-36"><a href="#cb1-36" aria-hidden="true" tabindex="-1"></a>single classes, and the decision of the overall classifier.</span>
<span id="cb1-37"><a href="#cb1-37" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-38"><a href="#cb1-38" aria-hidden="true" tabindex="-1"></a>Graphically, it looks like this:</span>
<span id="cb1-39"><a href="#cb1-39" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-40"><a href="#cb1-40" aria-hidden="true" tabindex="-1"></a><span class="al">![A binary tree to convert single-class predictors into multi-class predictors.](ecoc-binary-tree.png)</span></span>
<span id="cb1-41"><a href="#cb1-41" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-42"><a href="#cb1-42" aria-hidden="true" tabindex="-1"></a>If you compare this scheme to the OVA and AVA ideas, you can notice a</span>
<span id="cb1-43"><a href="#cb1-43" aria-hidden="true" tabindex="-1"></a>few similarities and a few differences.</span>
<span id="cb1-44"><a href="#cb1-44" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-45"><a href="#cb1-45" aria-hidden="true" tabindex="-1"></a>First, the number of classifiers you need to train in this scheme is</span>
<span id="cb1-46"><a href="#cb1-46" aria-hidden="true" tabindex="-1"></a>comparable to that of OVA (in a binary tree with $k$ leaves, there are</span>
<span id="cb1-47"><a href="#cb1-47" aria-hidden="true" tabindex="-1"></a>always $k-1$ nodes).</span>
<span id="cb1-48"><a href="#cb1-48" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-49"><a href="#cb1-49" aria-hidden="true" tabindex="-1"></a>In OVA, all classifiers are unbalanced, in that you're training</span>
<span id="cb1-50"><a href="#cb1-50" aria-hidden="true" tabindex="-1"></a>"class-$i$ vs. class-not-$i$" subproblems. Here, your classification</span>
<span id="cb1-51"><a href="#cb1-51" aria-hidden="true" tabindex="-1"></a>problems are all balanced. The leaves of the binary tree classifier</span>
<span id="cb1-52"><a href="#cb1-52" aria-hidden="true" tabindex="-1"></a>are identical to some of the AVA classifiers, but the internal nodes</span>
<span id="cb1-53"><a href="#cb1-53" aria-hidden="true" tabindex="-1"></a>combine multiple classes. This can be both good and bad: it's</span>
<span id="cb1-54"><a href="#cb1-54" aria-hidden="true" tabindex="-1"></a>bad in that if you have multiple classes that look very different from</span>
<span id="cb1-55"><a href="#cb1-55" aria-hidden="true" tabindex="-1"></a>one another, you'll be trying to "teach your classifier more than one</span>
<span id="cb1-56"><a href="#cb1-56" aria-hidden="true" tabindex="-1"></a>thing at once". That's not great. But if the classes in the same side</span>
<span id="cb1-57"><a href="#cb1-57" aria-hidden="true" tabindex="-1"></a>of the internal nodes are similar enough, then combining them means</span>
<span id="cb1-58"><a href="#cb1-58" aria-hidden="true" tabindex="-1"></a>that the training process for that node will be able to "share</span>
<span id="cb1-59"><a href="#cb1-59" aria-hidden="true" tabindex="-1"></a>knowledge from its lessons". And that's a good thing.</span>
<span id="cb1-60"><a href="#cb1-60" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-61"><a href="#cb1-61" aria-hidden="true" tabindex="-1"></a>Unlike OVA or AVA, the number of decisions you need to make at test</span>
<span id="cb1-62"><a href="#cb1-62" aria-hidden="true" tabindex="-1"></a>time is quite small. Here, the path from the tree root to a leaf has</span>
<span id="cb1-63"><a href="#cb1-63" aria-hidden="true" tabindex="-1"></a>$O(\log k)$ nodes, while OVA needs $O(k)$ classifiers, and AVA,</span>
<span id="cb1-64"><a href="#cb1-64" aria-hidden="true" tabindex="-1"></a>$O(k^2)$. This means that if your binary classifiers achieve an error</span>
<span id="cb1-65"><a href="#cb1-65" aria-hidden="true" tabindex="-1"></a>rate of $\epsilon$, then you can trivially see that the multiclass</span>
<span id="cb1-66"><a href="#cb1-66" aria-hidden="true" tabindex="-1"></a>classifier will achieve an error rate of $O(\log k) \epsilon$.</span>
<span id="cb1-67"><a href="#cb1-67" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-68"><a href="#cb1-68" aria-hidden="true" tabindex="-1"></a><span class="fu">## Reducing the number of base classifiers</span></span>
<span id="cb1-69"><a href="#cb1-69" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-70"><a href="#cb1-70" aria-hidden="true" tabindex="-1"></a>Now let's make things a little weird. Say that you think your base</span>
<span id="cb1-71"><a href="#cb1-71" aria-hidden="true" tabindex="-1"></a>binary classifier procedure is so good, that it will be able to</span>
<span id="cb1-72"><a href="#cb1-72" aria-hidden="true" tabindex="-1"></a>distinguish between *any* partition of classes from the original</span>
<span id="cb1-73"><a href="#cb1-73" aria-hidden="true" tabindex="-1"></a>problem that you give it. What's the minimum number of classifiers you</span>
<span id="cb1-74"><a href="#cb1-74" aria-hidden="true" tabindex="-1"></a>have to train? It is easy to see what that number must be. If you think of</span>
<span id="cb1-75"><a href="#cb1-75" aria-hidden="true" tabindex="-1"></a>the decision of the final multiclass classifier as producing a word in</span>
<span id="cb1-76"><a href="#cb1-76" aria-hidden="true" tabindex="-1"></a>binary, then clearly we need $O(\log_2 k)$ binary digits to write out that word. But a binary</span>
<span id="cb1-77"><a href="#cb1-77" aria-hidden="true" tabindex="-1"></a>digit is the best we can get out of a binary classifier, so we need</span>
<span id="cb1-78"><a href="#cb1-78" aria-hidden="true" tabindex="-1"></a>$O(\log_2 k)$ of them as well.</span>
<span id="cb1-79"><a href="#cb1-79" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-80"><a href="#cb1-80" aria-hidden="true" tabindex="-1"></a>This also clearly suggests the way to build the classifier: write out</span>
<span id="cb1-81"><a href="#cb1-81" aria-hidden="true" tabindex="-1"></a>the multiple class labels in binary representation, and now the job of</span>
<span id="cb1-82"><a href="#cb1-82" aria-hidden="true" tabindex="-1"></a>the $i$-th of $\log_2 k$ binary classifiers is to predict the $i$-th</span>
<span id="cb1-83"><a href="#cb1-83" aria-hidden="true" tabindex="-1"></a>digit of that binary representation. This is the same thing as</span>
<span id="cb1-84"><a href="#cb1-84" aria-hidden="true" tabindex="-1"></a>building, for each of the level of the trees in the above example, a</span>
<span id="cb1-85"><a href="#cb1-85" aria-hidden="true" tabindex="-1"></a>*single classifier*, where that classifier predicts whether to take</span>
<span id="cb1-86"><a href="#cb1-86" aria-hidden="true" tabindex="-1"></a>the branch on the left or the right.</span>
<span id="cb1-87"><a href="#cb1-87" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-88"><a href="#cb1-88" aria-hidden="true" tabindex="-1"></a>In other words, for the same 8-class problem we had before, we build</span>
<span id="cb1-89"><a href="#cb1-89" aria-hidden="true" tabindex="-1"></a>classifiers that distinguish between:</span>
<span id="cb1-90"><a href="#cb1-90" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-91"><a href="#cb1-91" aria-hidden="true" tabindex="-1"></a><span class="ss">* </span><span class="in">`0123`</span> vs. <span class="in">`4567`</span></span>
<span id="cb1-92"><a href="#cb1-92" aria-hidden="true" tabindex="-1"></a><span class="ss">* </span><span class="in">`0145`</span> vs. <span class="in">`2367`</span></span>
<span id="cb1-93"><a href="#cb1-93" aria-hidden="true" tabindex="-1"></a><span class="ss">* </span><span class="in">`0246`</span> vs. <span class="in">`1357`</span></span>
<span id="cb1-94"><a href="#cb1-94" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-95"><a href="#cb1-95" aria-hidden="true" tabindex="-1"></a>Notice how there's only one class that's unique along any possible set</span>
<span id="cb1-96"><a href="#cb1-96" aria-hidden="true" tabindex="-1"></a>of decisions of the binary classifiers. Let's call this the "binary</span>
<span id="cb1-97"><a href="#cb1-97" aria-hidden="true" tabindex="-1"></a>transmission" method (TODO: find the actual name used in ML).</span>
<span id="cb1-98"><a href="#cb1-98" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-99"><a href="#cb1-99" aria-hidden="true" tabindex="-1"></a><span class="fu"># The magic of error correction</span></span>
<span id="cb1-100"><a href="#cb1-100" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-101"><a href="#cb1-101" aria-hidden="true" tabindex="-1"></a>This is pretty neat, but it turns out that the best is still ahead of</span>
<span id="cb1-102"><a href="#cb1-102" aria-hidden="true" tabindex="-1"></a>us!  The main thing we will address now is that it's not always the</span>
<span id="cb1-103"><a href="#cb1-103" aria-hidden="true" tabindex="-1"></a>case that our classifiers will be correct. And unlike the case with</span>
<span id="cb1-104"><a href="#cb1-104" aria-hidden="true" tabindex="-1"></a>AVA and OVA, base-level mistakes in the binary tree and binary</span>
<span id="cb1-105"><a href="#cb1-105" aria-hidden="true" tabindex="-1"></a>transmission methods are always catastrophic.</span>
<span id="cb1-106"><a href="#cb1-106" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-107"><a href="#cb1-107" aria-hidden="true" tabindex="-1"></a>The problem of transmitting information in the presence of noise has</span>
<span id="cb1-108"><a href="#cb1-108" aria-hidden="true" tabindex="-1"></a>been deeply studied since the early 20th century. The most magical</span>
<span id="cb1-109"><a href="#cb1-109" aria-hidden="true" tabindex="-1"></a>thing about changing perspectives is that it instantly gives us a lot</span>
<span id="cb1-110"><a href="#cb1-110" aria-hidden="true" tabindex="-1"></a>of new tools to think about a problem. So what if we pretend that each</span>
<span id="cb1-111"><a href="#cb1-111" aria-hidden="true" tabindex="-1"></a>binary classifier is sending its result along a telegraph, in which</span>
<span id="cb1-112"><a href="#cb1-112" aria-hidden="true" tabindex="-1"></a>mistakes can happen along the way? Then, the problem of fixing a</span>
<span id="cb1-113"><a href="#cb1-113" aria-hidden="true" tabindex="-1"></a>transmission mistake looks equivalent to the problem of making a</span>
<span id="cb1-114"><a href="#cb1-114" aria-hidden="true" tabindex="-1"></a>classifier error. So, *if we can fix a transmission mistake even if</span>
<span id="cb1-115"><a href="#cb1-115" aria-hidden="true" tabindex="-1"></a>every digit can fail, we might be able to fix a multiclassifier</span>
<span id="cb1-116"><a href="#cb1-116" aria-hidden="true" tabindex="-1"></a>mistake, even if every binary classifier can fail!*.</span>
<span id="cb1-117"><a href="#cb1-117" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-118"><a href="#cb1-118" aria-hidden="true" tabindex="-1"></a>In the following, we will look at a very simple error-correcting</span>
<span id="cb1-119"><a href="#cb1-119" aria-hidden="true" tabindex="-1"></a>code. The [state of the art for error correcting in multiclass</span>
<span id="cb1-120"><a href="#cb1-120" aria-hidden="true" tabindex="-1"></a>classifiers](http://hunch.net/~beygel/tournament.pdf) is much more</span>
<span id="cb1-121"><a href="#cb1-121" aria-hidden="true" tabindex="-1"></a>complicated than this, but the principle is the same.</span>
<span id="cb1-122"><a href="#cb1-122" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-123"><a href="#cb1-123" aria-hidden="true" tabindex="-1"></a>The idea itself behind error correcting codes is simple. Say we want</span>
<span id="cb1-124"><a href="#cb1-124" aria-hidden="true" tabindex="-1"></a>to transmit a word that can be one of <span class="in">`000`</span>, <span class="in">`001`</span>, <span class="in">`010`</span>, <span class="in">`011`</span>,</span>
<span id="cb1-125"><a href="#cb1-125" aria-hidden="true" tabindex="-1"></a><span class="in">`100`</span>, <span class="in">`101`</span>, <span class="in">`110`</span>, or <span class="in">`111`</span>. We will model a transmission error as</span>
<span id="cb1-126"><a href="#cb1-126" aria-hidden="true" tabindex="-1"></a>flipping one of the bits of those words. If we send this</span>
<span id="cb1-127"><a href="#cb1-127" aria-hidden="true" tabindex="-1"></a>representation directly, then any errors that happen in the</span>
<span id="cb1-128"><a href="#cb1-128" aria-hidden="true" tabindex="-1"></a>transmission will become indistinguishable from a successful</span>
<span id="cb1-129"><a href="#cb1-129" aria-hidden="true" tabindex="-1"></a>transmission of a different message. This is a problem, because we</span>
<span id="cb1-130"><a href="#cb1-130" aria-hidden="true" tabindex="-1"></a>won't even know when something bad happens. It needs to be possible</span>
<span id="cb1-131"><a href="#cb1-131" aria-hidden="true" tabindex="-1"></a>for our communication process to know, by looking at the transmitted</span>
<span id="cb1-132"><a href="#cb1-132" aria-hidden="true" tabindex="-1"></a>word, that something wrong happened. So there needs to be enough</span>
<span id="cb1-133"><a href="#cb1-133" aria-hidden="true" tabindex="-1"></a>*room* in the space of possible messages for the case where "bad stuff</span>
<span id="cb1-134"><a href="#cb1-134" aria-hidden="true" tabindex="-1"></a>happened". This means that we will have to *encode* the word we want</span>
<span id="cb1-135"><a href="#cb1-135" aria-hidden="true" tabindex="-1"></a>to send into a bigger space of possible transmissions, a space with more room.</span>
<span id="cb1-136"><a href="#cb1-136" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-137"><a href="#cb1-137" aria-hidden="true" tabindex="-1"></a>In addition, in this new space of possible transmission, every</span>
<span id="cb1-138"><a href="#cb1-138" aria-hidden="true" tabindex="-1"></a>codeword should be far away from one another (where we [measure</span>
<span id="cb1-139"><a href="#cb1-139" aria-hidden="true" tabindex="-1"></a>distance by flipping</span>
<span id="cb1-140"><a href="#cb1-140" aria-hidden="true" tabindex="-1"></a>bits](https://en.wikipedia.org/wiki/Hamming_distance), the same</span>
<span id="cb1-141"><a href="#cb1-141" aria-hidden="true" tabindex="-1"></a>process that we assume was introducing mistakes), because we want to</span>
<span id="cb1-142"><a href="#cb1-142" aria-hidden="true" tabindex="-1"></a>give every codeword a "safety cushion" for errors, so that if we get a</span>
<span id="cb1-143"><a href="#cb1-143" aria-hidden="true" tabindex="-1"></a>bad transmission, there's only one codeword nearby, so we will know</span>
<span id="cb1-144"><a href="#cb1-144" aria-hidden="true" tabindex="-1"></a>how to correct that mistake.</span>
<span id="cb1-145"><a href="#cb1-145" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-146"><a href="#cb1-146" aria-hidden="true" tabindex="-1"></a>There are simple error detection methods, like sending the same</span>
<span id="cb1-147"><a href="#cb1-147" aria-hidden="true" tabindex="-1"></a>message three times. If any of the words disagree with one another,</span>
<span id="cb1-148"><a href="#cb1-148" aria-hidden="true" tabindex="-1"></a>then we know a mistake happened somewhere (and we correct it by</span>
<span id="cb1-149"><a href="#cb1-149" aria-hidden="true" tabindex="-1"></a>majority voting).</span>
<span id="cb1-150"><a href="#cb1-150" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-151"><a href="#cb1-151" aria-hidden="true" tabindex="-1"></a>This, however, is not a very efficient code, and most importantly, it</span>
<span id="cb1-152"><a href="#cb1-152" aria-hidden="true" tabindex="-1"></a>will not work in the case of multiclass classification! When sending</span>
<span id="cb1-153"><a href="#cb1-153" aria-hidden="true" tabindex="-1"></a>messages on radio, each error happens (<span class="co">[</span><span class="ot">well, kinda</span><span class="co">](https://en.wikipedia.org/wiki/Burst_error)</span>) independently of one another.</span>
<span id="cb1-154"><a href="#cb1-154" aria-hidden="true" tabindex="-1"></a>But in our case, a mistake happens when a classifier does badly for a given example. So if we just try to "send the same digit three times", it'll be the case</span>
<span id="cb1-155"><a href="#cb1-155" aria-hidden="true" tabindex="-1"></a>that if we make a mistake once, then we will make it three times! We need to come up with a better method.</span>
<span id="cb1-156"><a href="#cb1-156" aria-hidden="true" tabindex="-1"></a>(Specifically, I will describe below the [Hamming(7,4)</span>
<span id="cb1-157"><a href="#cb1-157" aria-hidden="true" tabindex="-1"></a>code](https://en.wikipedia.org/wiki/Hamming(7,4)).)</span>
<span id="cb1-158"><a href="#cb1-158" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-159"><a href="#cb1-159" aria-hidden="true" tabindex="-1"></a><span class="fu">## Let's not repeat digits</span></span>
<span id="cb1-160"><a href="#cb1-160" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-161"><a href="#cb1-161" aria-hidden="true" tabindex="-1"></a>The code I'm going to describe to you works on 4-bit words, so for now</span>
<span id="cb1-162"><a href="#cb1-162" aria-hidden="true" tabindex="-1"></a>let's pretend that our original problem had 16 classes instead</span>
<span id="cb1-163"><a href="#cb1-163" aria-hidden="true" tabindex="-1"></a>of 8. The encoding process is itself very easy to describe. We send</span>
<span id="cb1-164"><a href="#cb1-164" aria-hidden="true" tabindex="-1"></a>the 4-bit word into a 7-bit space:</span>
<span id="cb1-165"><a href="#cb1-165" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-166"><a href="#cb1-166" aria-hidden="true" tabindex="-1"></a><span class="ss">* </span>$A = d<span class="sc">\_</span>1\ \textrm{xor}\ d<span class="sc">\_</span>2\ \textrm{xor}\ d<span class="sc">\_</span>4$</span>
<span id="cb1-167"><a href="#cb1-167" aria-hidden="true" tabindex="-1"></a><span class="ss">* </span>$B = d<span class="sc">\_</span>1\ \textrm{xor}\ d<span class="sc">\_</span>3\ \textrm{xor}\ d<span class="sc">\_</span>4$</span>
<span id="cb1-168"><a href="#cb1-168" aria-hidden="true" tabindex="-1"></a><span class="ss">* </span>$C = d<span class="sc">\_</span>2\ \textrm{xor}\ d<span class="sc">\_</span>3\ \textrm{xor}\ d<span class="sc">\_</span>4$</span>
<span id="cb1-169"><a href="#cb1-169" aria-hidden="true" tabindex="-1"></a><span class="ss">* </span>$D = d<span class="sc">\_</span>1$</span>
<span id="cb1-170"><a href="#cb1-170" aria-hidden="true" tabindex="-1"></a><span class="ss">* </span>$E = d<span class="sc">\_</span>2$</span>
<span id="cb1-171"><a href="#cb1-171" aria-hidden="true" tabindex="-1"></a><span class="ss">* </span>$F = d<span class="sc">\_</span>3$</span>
<span id="cb1-172"><a href="#cb1-172" aria-hidden="true" tabindex="-1"></a><span class="ss">* </span>$G = d<span class="sc">\_</span>4$</span>
<span id="cb1-173"><a href="#cb1-173" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-174"><a href="#cb1-174" aria-hidden="true" tabindex="-1"></a>Here, $d<span class="sc">\_</span>1$ through $d<span class="sc">\_</span>4$ are the digits of the word we want to</span>
<span id="cb1-175"><a href="#cb1-175" aria-hidden="true" tabindex="-1"></a>send. As we argued above, it must be the case that this code is</span>
<span id="cb1-176"><a href="#cb1-176" aria-hidden="true" tabindex="-1"></a>redundant. Indeed, any valid word respects the following equations:</span>
<span id="cb1-177"><a href="#cb1-177" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-178"><a href="#cb1-178" aria-hidden="true" tabindex="-1"></a><span class="ss">* </span>$A\ \textrm{xor}\ D\ \textrm{xor}\ E\ \textrm{xor}\ G = 0$</span>
<span id="cb1-179"><a href="#cb1-179" aria-hidden="true" tabindex="-1"></a><span class="ss">* </span>$B\ \textrm{xor}\ D\ \textrm{xor}\ F\ \textrm{xor}\ G = 0$</span>
<span id="cb1-180"><a href="#cb1-180" aria-hidden="true" tabindex="-1"></a><span class="ss">* </span>$C\ \textrm{xor}\ E\ \textrm{xor}\ F\ \textrm{xor}\ G = 0$</span>
<span id="cb1-181"><a href="#cb1-181" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-182"><a href="#cb1-182" aria-hidden="true" tabindex="-1"></a>These equations are easy to prove: remember that $\textrm{xor}$ is</span>
<span id="cb1-183"><a href="#cb1-183" aria-hidden="true" tabindex="-1"></a>commutatitive and associative, and that $a\ \textrm{xor}\ a = 0$.</span>
<span id="cb1-184"><a href="#cb1-184" aria-hidden="true" tabindex="-1"></a>Moreover, the equations are also the key to making error detection work.</span>
<span id="cb1-185"><a href="#cb1-185" aria-hidden="true" tabindex="-1"></a>Here's a minor modification we will make. Let's assume that an error</span>
<span id="cb1-186"><a href="#cb1-186" aria-hidden="true" tabindex="-1"></a>can happen on any digit we send, so we replace $A$ with $\tilde{A}$,</span>
<span id="cb1-187"><a href="#cb1-187" aria-hidden="true" tabindex="-1"></a>etc:</span>
<span id="cb1-188"><a href="#cb1-188" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-189"><a href="#cb1-189" aria-hidden="true" tabindex="-1"></a><span class="ss">* </span>$\tilde{A} = \epsilon_A\ \textrm{xor}\ d<span class="sc">\_</span>1\ \textrm{xor}\ d<span class="sc">\_</span>2\ \textrm{xor}\ d<span class="sc">\_</span>4$</span>
<span id="cb1-190"><a href="#cb1-190" aria-hidden="true" tabindex="-1"></a><span class="ss">* </span>$\tilde{B} = \epsilon_B\ \textrm{xor}\ d<span class="sc">\_</span>1\ \textrm{xor}\ d<span class="sc">\_</span>3\ \textrm{xor}\ d<span class="sc">\_</span>4$</span>
<span id="cb1-191"><a href="#cb1-191" aria-hidden="true" tabindex="-1"></a><span class="ss">* </span>$\tilde{C} = \epsilon_C\ \textrm{xor}\ d<span class="sc">\_</span>2\ \textrm{xor}\ d<span class="sc">\_</span>3\ \textrm{xor}\ d<span class="sc">\_</span>4$</span>
<span id="cb1-192"><a href="#cb1-192" aria-hidden="true" tabindex="-1"></a><span class="ss">* </span>$\tilde{D} = \epsilon_D\ \textrm{xor}\ d<span class="sc">\_</span>1$</span>
<span id="cb1-193"><a href="#cb1-193" aria-hidden="true" tabindex="-1"></a><span class="ss">* </span>$\tilde{E} = \epsilon_E\ \textrm{xor}\ d<span class="sc">\_</span>2$</span>
<span id="cb1-194"><a href="#cb1-194" aria-hidden="true" tabindex="-1"></a><span class="ss">* </span>$\tilde{F} = \epsilon_F\ \textrm{xor}\ d<span class="sc">\_</span>3$</span>
<span id="cb1-195"><a href="#cb1-195" aria-hidden="true" tabindex="-1"></a><span class="ss">* </span>$\tilde{G} = \epsilon_G\ \textrm{xor}\ d<span class="sc">\_</span>4$</span>
<span id="cb1-196"><a href="#cb1-196" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-197"><a href="#cb1-197" aria-hidden="true" tabindex="-1"></a>Here, we use $\epsilon<span class="sc">\_</span>A$, $\epsilon<span class="sc">\_</span>B$, etc. to model errors in our</span>
<span id="cb1-198"><a href="#cb1-198" aria-hidden="true" tabindex="-1"></a>transmission. The code we are describing here can only correct</span>
<span id="cb1-199"><a href="#cb1-199" aria-hidden="true" tabindex="-1"></a>mistakes if only one of them happens at a time. That means that for</span>
<span id="cb1-200"><a href="#cb1-200" aria-hidden="true" tabindex="-1"></a>every transmission, either $\epsilon<span class="sc">\_</span>A = \epsilon<span class="sc">\_</span>B = \cdots = 0$,</span>
<span id="cb1-201"><a href="#cb1-201" aria-hidden="true" tabindex="-1"></a>or a single one of the $\epsilon$ variables is one and all the others</span>
<span id="cb1-202"><a href="#cb1-202" aria-hidden="true" tabindex="-1"></a>are still zero.</span>
<span id="cb1-203"><a href="#cb1-203" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-204"><a href="#cb1-204" aria-hidden="true" tabindex="-1"></a>This is where the magic happens. Let's say $\epsilon_A = 1$. Although</span>
<span id="cb1-205"><a href="#cb1-205" aria-hidden="true" tabindex="-1"></a>it seems like it will be hard to figure out that something went wrong</span>
<span id="cb1-206"><a href="#cb1-206" aria-hidden="true" tabindex="-1"></a>(since the 7-bit word we transmitted "looks fine"), let's look at</span>
<span id="cb1-207"><a href="#cb1-207" aria-hidden="true" tabindex="-1"></a>those three equations that we derived which describe the redundancy in the code. Now, consider their equivalents with</span>
<span id="cb1-208"><a href="#cb1-208" aria-hidden="true" tabindex="-1"></a>$\tilde{A}$, etc. I'm also giving each term a name now, $c<span class="sc">\_</span>0$ through $c<span class="sc">\_</span>2$:</span>
<span id="cb1-209"><a href="#cb1-209" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-210"><a href="#cb1-210" aria-hidden="true" tabindex="-1"></a><span class="ss">* </span>$c<span class="sc">\_</span>0 = \tilde{A}\ \textrm{xor}\ \tilde{D}\ \textrm{xor}\ \tilde{E}\ \textrm{xor}\ \tilde{G} = \epsilon<span class="sc">\_</span>{A}\ \textrm{xor}\ \epsilon<span class="sc">\_</span>{D}\ \textrm{xor}\ \epsilon<span class="sc">\_</span>{E}\ \textrm{xor}\ \epsilon<span class="sc">\_</span>{G}$</span>
<span id="cb1-211"><a href="#cb1-211" aria-hidden="true" tabindex="-1"></a><span class="ss">* </span>$c<span class="sc">\_</span>1 = \tilde{B}\ \textrm{xor}\ \tilde{D}\ \textrm{xor}\ \tilde{F}\ \textrm{xor}\ \tilde{G} = \epsilon<span class="sc">\_</span>{B}\ \textrm{xor}\ \epsilon<span class="sc">\_</span>{D}\ \textrm{xor}\ \epsilon<span class="sc">\_</span>{F}\ \textrm{xor}\ \epsilon<span class="sc">\_</span>{G}$</span>
<span id="cb1-212"><a href="#cb1-212" aria-hidden="true" tabindex="-1"></a><span class="ss">* </span>$c<span class="sc">\_</span>2 = \tilde{C}\ \textrm{xor}\ \tilde{E}\ \textrm{xor}\ \tilde{F}\ \textrm{xor}\ \tilde{G} = \epsilon<span class="sc">\_</span>{C}\ \textrm{xor}\ \epsilon<span class="sc">\_</span>{E}\ \textrm{xor}\ \epsilon<span class="sc">\_</span>{F}\ \textrm{xor}\ \epsilon<span class="sc">\_</span>{G}$</span>
<span id="cb1-213"><a href="#cb1-213" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-214"><a href="#cb1-214" aria-hidden="true" tabindex="-1"></a>Notice two very important things on the right hand sides: every</span>
<span id="cb1-215"><a href="#cb1-215" aria-hidden="true" tabindex="-1"></a>error variable appears at least once, and no error variable was</span>
<span id="cb1-216"><a href="#cb1-216" aria-hidden="true" tabindex="-1"></a>cancelled out from appearing more than once in the left-hand sides.</span>
<span id="cb1-217"><a href="#cb1-217" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-218"><a href="#cb1-218" aria-hidden="true" tabindex="-1"></a>There's also a less immediate property of these $c$ variables: *every</span>
<span id="cb1-219"><a href="#cb1-219" aria-hidden="true" tabindex="-1"></a>possible mistake case creates a different configuration of $c<span class="sc">\_</span>0$,</span>
<span id="cb1-220"><a href="#cb1-220" aria-hidden="true" tabindex="-1"></a>$c<span class="sc">\_</span>1$, and $c<span class="sc">\_</span>2$*! This is truly remarkable, and you should check it</span>
<span id="cb1-221"><a href="#cb1-221" aria-hidden="true" tabindex="-1"></a>for yourself, by setting the values of $\epsilon<span class="sc">\_</span>A$ through</span>
<span id="cb1-222"><a href="#cb1-222" aria-hidden="true" tabindex="-1"></a>$\epsilon<span class="sc">\_</span>G$ to 1. For example, you should be able to convince</span>
<span id="cb1-223"><a href="#cb1-223" aria-hidden="true" tabindex="-1"></a>yourself that if $c<span class="sc">\_</span>0 = 0$, $c<span class="sc">\_</span>1 = 1$, and $c<span class="sc">\_</span>2 = 1$, then it must</span>
<span id="cb1-224"><a href="#cb1-224" aria-hidden="true" tabindex="-1"></a>be the case that $\epsilon<span class="sc">\_</span>{F} = 1$, which means that the mistake</span>
<span id="cb1-225"><a href="#cb1-225" aria-hidden="true" tabindex="-1"></a>happened on $\tilde{F}$, which in turn means that all we have to do is</span>
<span id="cb1-226"><a href="#cb1-226" aria-hidden="true" tabindex="-1"></a>flip $\tilde{F}$ to obtain $F$, and all other digits must be correct!</span>
<span id="cb1-227"><a href="#cb1-227" aria-hidden="true" tabindex="-1"></a>If all $c$s are zero, then no error happened. (Again, we are assuming</span>
<span id="cb1-228"><a href="#cb1-228" aria-hidden="true" tabindex="-1"></a>that errors happen only one at a time. Fate is not always this kind.)</span>
<span id="cb1-229"><a href="#cb1-229" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-230"><a href="#cb1-230" aria-hidden="true" tabindex="-1"></a><span class="fu">## Now to turn this into a multiclass reduction</span></span>
<span id="cb1-231"><a href="#cb1-231" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-232"><a href="#cb1-232" aria-hidden="true" tabindex="-1"></a>The final remarkable property of this error-correcting code is that</span>
<span id="cb1-233"><a href="#cb1-233" aria-hidden="true" tabindex="-1"></a>each digit in the new transmission is formed by a particular</span>
<span id="cb1-234"><a href="#cb1-234" aria-hidden="true" tabindex="-1"></a>combination of the digits in the original problem. Let's think of the binary classification problems in the "binary transmission" reduction. (Here, I'll slip into hexadecimal notation and call the 16 classes <span class="in">`0123456789abcdef`</span>):</span>
<span id="cb1-235"><a href="#cb1-235" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-236"><a href="#cb1-236" aria-hidden="true" tabindex="-1"></a><span class="ss">* </span>$d_1$: <span class="kw">&lt;tt&gt;</span>01234567<span class="dv">&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;</span><span class="kw">&lt;/tt&gt;</span> vs. the negative: <span class="kw">&lt;tt&gt;</span><span class="dv">&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;</span>89abcdef<span class="kw">&lt;/tt&gt;</span></span>
<span id="cb1-237"><a href="#cb1-237" aria-hidden="true" tabindex="-1"></a><span class="ss">* </span>$d_2$: <span class="kw">&lt;tt&gt;</span>0123<span class="dv">&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;</span>89ab<span class="dv">&amp;nbsp;&amp;nbsp;&amp;nbsp;</span><span class="kw">&lt;/tt&gt;</span> vs. the negative: <span class="kw">&lt;tt&gt;</span><span class="dv">&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;</span>4567<span class="dv">&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;</span>cdef<span class="kw">&lt;/tt&gt;</span></span>
<span id="cb1-238"><a href="#cb1-238" aria-hidden="true" tabindex="-1"></a><span class="ss">* </span>$d_3$: <span class="kw">&lt;tt&gt;</span>01<span class="dv">&amp;nbsp;&amp;nbsp;</span>45<span class="dv">&amp;nbsp;&amp;nbsp;</span>89<span class="dv">&amp;nbsp;&amp;nbsp;</span>cd<span class="dv">&amp;nbsp;</span><span class="kw">&lt;/tt&gt;</span> vs. the negative: <span class="kw">&lt;tt&gt;</span><span class="dv">&amp;nbsp;&amp;nbsp;</span>23<span class="dv">&amp;nbsp;&amp;nbsp;</span>67<span class="dv">&amp;nbsp;&amp;nbsp;</span>ab<span class="dv">&amp;nbsp;&amp;nbsp;</span>ef<span class="kw">&lt;/tt&gt;</span></span>
<span id="cb1-239"><a href="#cb1-239" aria-hidden="true" tabindex="-1"></a><span class="ss">* </span>$d_4$: <span class="kw">&lt;tt&gt;</span>0<span class="dv">&amp;nbsp;</span>2<span class="dv">&amp;nbsp;</span>4<span class="dv">&amp;nbsp;</span>6<span class="dv">&amp;nbsp;</span>8<span class="dv">&amp;nbsp;</span>a<span class="dv">&amp;nbsp;</span>c<span class="dv">&amp;nbsp;</span>e<span class="kw">&lt;/tt&gt;</span> vs. the negative: <span class="kw">&lt;tt&gt;</span><span class="dv">&amp;nbsp;</span>1<span class="dv">&amp;nbsp;</span>3<span class="dv">&amp;nbsp;</span>5<span class="dv">&amp;nbsp;</span>7<span class="dv">&amp;nbsp;</span>9<span class="dv">&amp;nbsp;</span>b<span class="dv">&amp;nbsp;</span>d<span class="dv">&amp;nbsp;</span>f<span class="kw">&lt;/tt&gt;</span></span>
<span id="cb1-240"><a href="#cb1-240" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-241"><a href="#cb1-241" aria-hidden="true" tabindex="-1"></a>(The whitespace is there simply to make the logic more apparent.)</span>
<span id="cb1-242"><a href="#cb1-242" aria-hidden="true" tabindex="-1"></a>These are our "base-digits" classifiers. The "checksum-digit" classifiers, that is, the redundant classifiers we will build to let us fix mistakes, will use the $\textrm{xor}$ operation as well.</span>
<span id="cb1-243"><a href="#cb1-243" aria-hidden="true" tabindex="-1"></a>Concretely speaking, the classifier for $d<span class="sc">\_</span>1\ \textrm{xor}\ d<span class="sc">\_</span>2\ \textrm{xor}\ d<span class="sc">\_</span>4$ (that is, our transmitted digit $\tilde{A}$ above) should return a positive label when</span>
<span id="cb1-244"><a href="#cb1-244" aria-hidden="true" tabindex="-1"></a>$d<span class="sc">\_</span>1\ \textrm{xor}\ d<span class="sc">\_</span>2\ \textrm{xor}\ d<span class="sc">\_</span>4 = 1$, or equivalently, it should</span>
<span id="cb1-245"><a href="#cb1-245" aria-hidden="true" tabindex="-1"></a>separate the classes <span class="in">`02579bce`</span> from <span class="in">`13468adf`</span>.</span>
<span id="cb1-246"><a href="#cb1-246" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-247"><a href="#cb1-247" aria-hidden="true" tabindex="-1"></a>Take a moment to convince yourself of why that makes sense: that split</span>
<span id="cb1-248"><a href="#cb1-248" aria-hidden="true" tabindex="-1"></a>separates the classes that appear in $d<span class="sc">\_</span>1$, $d<span class="sc">\_</span>2$, or $d<span class="sc">\_</span>4$ an odd number of times from those that appear there an</span>
<span id="cb1-249"><a href="#cb1-249" aria-hidden="true" tabindex="-1"></a>even number of times.  In other words, this classifier will "attempt</span>
<span id="cb1-250"><a href="#cb1-250" aria-hidden="true" tabindex="-1"></a>to send 1" if $d<span class="sc">\_</span>1\ \textrm{xor}\ d<span class="sc">\_</span>2\ \textrm{xor}\ d<span class="sc">\_</span>4 = 1$, and</span>
<span id="cb1-251"><a href="#cb1-251" aria-hidden="true" tabindex="-1"></a>"attempt to send 0" if $d<span class="sc">\_</span>1\ \textrm{xor}\ d<span class="sc">\_</span>2\ \textrm{xor}\ d<span class="sc">\_</span>4 =</span>
<span id="cb1-252"><a href="#cb1-252" aria-hidden="true" tabindex="-1"></a>0$, *exactly like our communication example!*</span>
<span id="cb1-253"><a href="#cb1-253" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-254"><a href="#cb1-254" aria-hidden="true" tabindex="-1"></a>Now, every time any one of our classifiers makes an isolated mistake,</span>
<span id="cb1-255"><a href="#cb1-255" aria-hidden="true" tabindex="-1"></a>we will be able to spot it and fix it, at the expense of training only</span>
<span id="cb1-256"><a href="#cb1-256" aria-hidden="true" tabindex="-1"></a>three more classifiers. And all of these classifiers are trained on different label distributions, and so we don't run into the issue of repeated classification mistakes (like we would if we used the "repeat transmission" code).</span>
<span id="cb1-257"><a href="#cb1-257" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-258"><a href="#cb1-258" aria-hidden="true" tabindex="-1"></a>Isn't that amazing?</span>
<span id="cb1-259"><a href="#cb1-259" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-260"><a href="#cb1-260" aria-hidden="true" tabindex="-1"></a><span class="fu"># Further reading</span></span>
<span id="cb1-261"><a href="#cb1-261" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-262"><a href="#cb1-262" aria-hidden="true" tabindex="-1"></a>There are a number of details that have to be handled when actually</span>
<span id="cb1-263"><a href="#cb1-263" aria-hidden="true" tabindex="-1"></a>deploying this strategy. The main one is that the choice on how to</span>
<span id="cb1-264"><a href="#cb1-264" aria-hidden="true" tabindex="-1"></a>order the classes to create those splits is quite important, both</span>
<span id="cb1-265"><a href="#cb1-265" aria-hidden="true" tabindex="-1"></a>because we need the individual classifiers to be good, and because we</span>
<span id="cb1-266"><a href="#cb1-266" aria-hidden="true" tabindex="-1"></a>need digit errors to be relatively uncorrelated to one another.</span>
<span id="cb1-267"><a href="#cb1-267" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-268"><a href="#cb1-268" aria-hidden="true" tabindex="-1"></a>In practice, what the literature suggests is to *invent a new custom</span>
<span id="cb1-269"><a href="#cb1-269" aria-hidden="true" tabindex="-1"></a>code for every multiclass classification problem*. This is easier than</span>
<span id="cb1-270"><a href="#cb1-270" aria-hidden="true" tabindex="-1"></a>it looks, and if you're interested, then Dietterich and</span>
<span id="cb1-271"><a href="#cb1-271" aria-hidden="true" tabindex="-1"></a>Bakiri's <span class="co">[</span><span class="ot">seminal paper</span><span class="co">](https://arxiv.org/pdf/cs/9501101.pdf)</span> is what</span>
<span id="cb1-272"><a href="#cb1-272" aria-hidden="true" tabindex="-1"></a>you should read next. This technique is now known as ECOC</span>
<span id="cb1-273"><a href="#cb1-273" aria-hidden="true" tabindex="-1"></a>("error-correcting output codes").</span>
<span id="cb1-274"><a href="#cb1-274" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-275"><a href="#cb1-275" aria-hidden="true" tabindex="-1"></a>The question of whether ECOC's are the best we can do remained open</span>
<span id="cb1-276"><a href="#cb1-276" aria-hidden="true" tabindex="-1"></a>for a while, and although it's still not completely settled, a (much</span>
<span id="cb1-277"><a href="#cb1-277" aria-hidden="true" tabindex="-1"></a>more complicated) solution that combines error correction with the</span>
<span id="cb1-278"><a href="#cb1-278" aria-hidden="true" tabindex="-1"></a>binary tournament idea from above gets pretty close to optimal. These</span>
<span id="cb1-279"><a href="#cb1-279" aria-hidden="true" tabindex="-1"></a>are <span class="co">[</span><span class="ot">error-correcting tournaments</span><span class="co">](https://arxiv.org/abs/0902.3176)</span>,</span>
<span id="cb1-280"><a href="#cb1-280" aria-hidden="true" tabindex="-1"></a>proposed by Beygelzimer et al. I confess I don't actually understand</span>
<span id="cb1-281"><a href="#cb1-281" aria-hidden="true" tabindex="-1"></a>ECTs all that well, but the good news is that at least they're</span>
<span id="cb1-282"><a href="#cb1-282" aria-hidden="true" tabindex="-1"></a>implemented in [Vowpal</span>
<span id="cb1-283"><a href="#cb1-283" aria-hidden="true" tabindex="-1"></a>Wabbit](https://github.com/VowpalWabbit/vowpal_wabbit). If</span>
<span id="cb1-284"><a href="#cb1-284" aria-hidden="true" tabindex="-1"></a>each of the base classifiers achieves an average error rate of</span>
<span id="cb1-285"><a href="#cb1-285" aria-hidden="true" tabindex="-1"></a>$\epsilon$, error-correcting tournaments achieve a multiclass error</span>
<span id="cb1-286"><a href="#cb1-286" aria-hidden="true" tabindex="-1"></a>bound of $2 \epsilon$. This is independent of the number of classes in</span>
<span id="cb1-287"><a href="#cb1-287" aria-hidden="true" tabindex="-1"></a>the multiclass problem, which is quite incredible.</span>
<span id="cb1-288"><a href="#cb1-288" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-289"><a href="#cb1-289" aria-hidden="true" tabindex="-1"></a><span class="fu">## Notes</span></span>
<span id="cb1-290"><a href="#cb1-290" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-291"><a href="#cb1-291" aria-hidden="true" tabindex="-1"></a><span class="ss">* </span>The reason we can't use the "repeat the same message more than once" trick</span>
<span id="cb1-292"><a href="#cb1-292" aria-hidden="true" tabindex="-1"></a>  is that we assumed we were always training the same</span>
<span id="cb1-293"><a href="#cb1-293" aria-hidden="true" tabindex="-1"></a>  classifier. If you have two binary classifiers for the same problem that</span>
<span id="cb1-294"><a href="#cb1-294" aria-hidden="true" tabindex="-1"></a>  both predict reasonably well, and whose predictions are</span>
<span id="cb1-295"><a href="#cb1-295" aria-hidden="true" tabindex="-1"></a>  relatively uncorrelated, then you can absolutely use this "repeat</span>
<span id="cb1-296"><a href="#cb1-296" aria-hidden="true" tabindex="-1"></a>  message" method. This turns out to work <span class="co">[</span><span class="ot">incredibly well in practice</span><span class="co">](https://en.wikipedia.org/wiki/Bootstrap_aggregating)</span>!</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div></div></div></div></div>
</div> <!-- /content -->
<footer class="footer">
  <div class="nav-footer">
    <div class="nav-footer-left">© Copyright 2022 Carlos Scheidegger. Except where otherwise noted, all text and images licensed CC-BY-NC 4.0.</div>   
  </div>
</footer>



</body></html>